#![allow(dead_code)]

use std::io::{self, Write};

use super::ast::{
    Constant, ConstantValue, FunctionDefinition, Node, UnaryExpression, UnaryOperation,
};

#[derive(Debug)]
struct AsmProgram {
    globals: Vec<String>,
    text: AsmSection,
    data: AsmSection,
}

#[derive(Debug)]
struct AsmSection {
    name: String,
    instructions: Vec<AsmInstruction>,
}

#[derive(Debug, Clone)]
pub enum AsmInstruction {
    Label(String),
    Move(String, String),
    Syscall,
}

impl AsmProgram {
    fn new() -> Self {
        let globals = vec!["_start".into()];
        let text = AsmSection {
            name: ".text".into(),
            instructions: vec![],
        };
        let data = AsmSection {
            name: ".data".into(),
            instructions: vec![],
        };

        AsmProgram {
            globals,
            text,
            data,
        }
    }

    fn append_text(&mut self, instruction: AsmInstruction) {
        self.text.instructions.push(instruction)
    }
}

#[derive(Debug)]
pub enum EmitError {
    UnknownInstruction(AsmInstruction),
    Io(io::Error),
    AsmParseError(AsmParseError),
}

impl From<io::Error> for EmitError {
    fn from(src: io::Error) -> EmitError {
        EmitError::Io(src)
    }
}

impl From<AsmParseError> for EmitError {
    fn from(src: AsmParseError) -> EmitError {
        EmitError::AsmParseError(src)
    }
}

trait Emit {
    fn emit(&self, writer: &mut dyn Write) -> Result<(), EmitError>;
}

impl Emit for AsmInstruction {
    fn emit(&self, writer: &mut dyn Write) -> Result<(), EmitError> {
        #[allow(unreachable_patterns)]
        match self {
            AsmInstruction::Label(s) => writeln!(writer, "{}:", s)?,
            AsmInstruction::Move(src, dst) => writeln!(writer, "\tmov {}, {}", src, dst)?,
            AsmInstruction::Syscall => writeln!(writer, "\tsyscall")?,
            _ => return Err(EmitError::UnknownInstruction(self.clone())),
        }
        Ok(())
    }
}

impl Emit for AsmSection {
    fn emit(&self, writer: &mut dyn Write) -> Result<(), EmitError> {
        writeln!(writer, "\t{}", self.name)?;
        for instruction in &self.instructions {
            instruction.emit(writer)?;
        }
        Ok(())
    }
}

impl Emit for AsmProgram {
    fn emit(&self, writer: &mut dyn Write) -> Result<(), EmitError> {
        write!(
            writer,
            "/*\nAuto-generated by Bonobo ASM generator\n  _____\no( . . )o\n __(-)__\n*/\n\n"
        )?;
        for var_name in &self.globals {
            writeln!(writer, "\t.global {}", var_name)?;
        }
        writeln!(writer)?;
        self.text.emit(writer)?;
        writeln!(writer)?;
        self.data.emit(writer)?;
        writeln!(writer, ".end")?;
        Ok(())
    }
}

#[derive(Debug)]
pub enum AsmParseError {
    UnknownAstNode,
}

#[derive(Debug)]
struct AsmParser {
    root: Node,
}

impl AsmParser {
    fn new(root: Node) -> Self {
        AsmParser { root }
    }

    fn parse_function(
        &self,
        mut program: AsmProgram,
        func: &FunctionDefinition,
    ) -> Result<AsmProgram, AsmParseError> {
        let label = match func.identifier.as_str() {
            "main" => "_start",
            s => s,
        };
        program.append_text(AsmInstruction::Label(label.into()));

        //Disregard parameters for now

        let mut result = Ok(program);

        for node in &func.body {
            result = self.parse_node(result?, node);
        }

        result
    }

    fn parse_return(&self, program: AsmProgram, inner: &Node) -> Result<AsmProgram, AsmParseError> {
        let mut prog = self.parse_node(program, inner)?;
        prog.append_text(AsmInstruction::Move("$60".into(), "%rax".into())); // platform specific
        prog.append_text(AsmInstruction::Syscall);
        Ok(prog)
    }

    fn parse_const_int(
        &self,
        mut program: AsmProgram,
        value: i64,
    ) -> Result<AsmProgram, AsmParseError> {
        program.append_text(AsmInstruction::Move(format!("${}", value), "%rdi".into()));
        Ok(program)
    }

    fn parse_node(&self, program: AsmProgram, node: &Node) -> Result<AsmProgram, AsmParseError> {
        let result = match node {
            Node::FunctionDefinition(func) => self.parse_function(program, func),
            Node::UnaryExpression(UnaryExpression {
                operation: UnaryOperation::Return,
                operand: inner,
            }) => self.parse_return(program, inner.as_ref()),
            Node::Constant(Constant {
                value: ConstantValue::Int64(val),
            }) => self.parse_const_int(program, *val),
            _ => Err(AsmParseError::UnknownAstNode),
        };

        result
    }

    fn parse(&self) -> Result<AsmProgram, AsmParseError> {
        let program = AsmProgram::new();
        self.parse_node(program, &self.root)
    }
}

pub fn emit(root: Node, writer: &mut dyn Write) -> Result<(), EmitError> {
    let parser = AsmParser::new(root);
    let program = parser.parse();

    program?.emit(writer)
}
