#![allow(dead_code)]

use std::io::{self, Write};

use crate::bonobo::asm::{
    AsmOperand, AsmProgram, operand::AsmInstruction, parser::AsmParseError, program::AsmSection,
};

#[derive(Debug)]
pub enum EmitError {
    Io(io::Error),
    AsmParseError(AsmParseError),
}

impl From<io::Error> for EmitError {
    fn from(src: io::Error) -> EmitError {
        EmitError::Io(src)
    }
}

impl From<AsmParseError> for EmitError {
    fn from(src: AsmParseError) -> EmitError {
        EmitError::AsmParseError(src)
    }
}

pub trait Emit {
    fn emit(&self, writer: &mut dyn Write) -> Result<(), EmitError>;
}

impl Emit for AsmInstruction {
    fn emit(&self, writer: &mut dyn Write) -> Result<(), EmitError> {
        match self {
            AsmInstruction::Label(s) => writeln!(writer, "{}:", s)?,
            AsmInstruction::Move(src, dst) => {
                writeln!(writer, "\t\tmov\t\t{}, {}", dst, src)?;
            }
            AsmInstruction::Swap(src, dst) => {
                writeln!(writer, "\t\txchg\t{}, {}", dst, src)?;
            }
            AsmInstruction::MoveEqual(src, dst) => {
                writeln!(writer, "\t\tcmove\t{}, {}", dst, src)?;
            }
            AsmInstruction::MoveNotEqual(src, dst) => {
                writeln!(writer, "\t\tcmovne\t{}, {}", dst, src)?;
            }
            AsmInstruction::Push(src) => {
                writeln!(writer, "\t\tpush\t{}", src)?;
            }
            AsmInstruction::Pop(dst) => {
                writeln!(writer, "\t\tpop\t\t{}", dst)?;
            }
            AsmInstruction::SetEqual(dst) => {
                writeln!(writer, "\t\tsete\t{}", dst)?;
            }
            AsmInstruction::Compare(src, dst) => {
                writeln!(writer, "\t\tcmp\t\t{}, {}", dst, src)?;
            }
            AsmInstruction::Jump(loc) => {
                writeln!(writer, "\t\tjmp\t\t{}", loc)?;
            }
            AsmInstruction::JumpEqual(loc) => {
                writeln!(writer, "\t\tje\t\t{}", loc)?;
            }
            AsmInstruction::Add(src, dst) => {
                writeln!(writer, "\t\tadd\t\t{}, {}", dst, src)?;
            }
            AsmInstruction::Subtract(src, dst) => {
                writeln!(writer, "\t\tsub\t\t{}, {}", dst, src)?;
            }
            AsmInstruction::SignedMultiply(src, dst) => {
                writeln!(writer, "\t\timul\t{}, {}", dst, src)?;
            }
            AsmInstruction::SignedDivide(divisor) => {
                writeln!(writer, "\t\tidiv\t{}", divisor)?;
            }
            AsmInstruction::Xor(src, dst) => {
                writeln!(writer, "\t\txor\t\t{}, {}", dst, src)?;
            }
            AsmInstruction::Cqo => writeln!(writer, "\t\tcqo")?,
            AsmInstruction::Syscall => writeln!(writer, "\t\tsyscall")?,
            AsmInstruction::Return => writeln!(writer, "\t\tret")?,
            AsmInstruction::FnCall(s) => writeln!(writer, "\t\tcall\t{}", s)?,
        }
        Ok(())
    }
}

impl Emit for AsmOperand {
    fn emit(&self, writer: &mut dyn Write) -> Result<(), EmitError> {
        write!(writer, "{}", self)?;
        Ok(())
    }
}

impl Emit for AsmSection {
    fn emit(&self, writer: &mut dyn Write) -> Result<(), EmitError> {
        writeln!(writer, "\t\tsection {}", self.name)?;
        for instruction in &self.instructions {
            instruction.emit(writer)?;
        }
        Ok(())
    }
}

impl Emit for AsmProgram {
    fn emit(&self, writer: &mut dyn Write) -> Result<(), EmitError> {
        write!(
            writer,
            ";Auto-generated by Bonobo ASM generator\n;  _____\n;o( . . )o\n; __(-)__\n\n"
        )?;
        for var_name in &self.globals {
            writeln!(writer, "\t\tglobal {}", var_name)?;
        }
        writeln!(writer)?;
        for var_name in &self.externs {
            writeln!(writer, "\t\textern {}", var_name)?;
        }
        writeln!(writer)?;
        self.text.emit(writer)?;
        writeln!(writer)?;
        self.data.emit(writer)?;
        Ok(())
    }
}
